# 操作系统的目标和功能
感觉这里通读下来就留点概念吧，上来说一堆功能感觉也没什么用，后面了解原理感觉自然就知道了

# 操作系统的演化
串行处理；我的理解就是向流水线一样，程序执行好了，就接着下面的内容
串行出现的问题：

## 简单批处理系统
1、监控程序的视角
里面的一些设计思想：
用户态/管态（内核态）：这是理解操作系统权限隔离的基础。

中断和陷阱（系统调用）：这是 CPU 从用户程序切换到操作系统，进行特权操作的唯一通道。

特权指令：哪些指令必须受保护。


## 多道批处理系统

进行的改进就是把简单批处理系统里面关于I/O操作浪费的时间给优化了，允许cpu在等待I/O的时候干其他的事情

## 分时系统
计时器，内存交换
# 操作系统的主要成就
## 进程
（1）多种定义，进程概念的产生是计算机系统发展的结果，多道程序批处理系统，分时和实时事务系统
（2）历史原因：如果由程序员来设定操作系统内部的管理，很容易出现各种问题，就产生了进程这个系统级的方法来金控处理器中不同程序的执行。
### 进程三要素
程序+程序的相关数据+程序的上下文
上下文是管理和控制进程所需的内部数据，这个和进程是分开的

### 又多了一个进程索引寄存器
进程被当做一个数据结构来实现，进程在内存里

这里具体是怎么实现进程的，进程和前面学习知识的联系还不知道


## 内存管理
提到了文件系统来实现长期管理，
虚存机制允许程序以逻辑方式访问存储器
里面新的概念挺多的，有页，有动态映射硬件，有

## 调度和资源管理
又提到了短程队列 长程队列 时间片轮转，分派器（）


## 现代os的特征
### 微内核体系结构
只给内核分配一些最基本的功能，如地址空间管理、进程间通信和基本的调度，剩下的都给用户内核
这个感觉和之前学习的用户内核和系统内核有关

### 对称多处理系统
就是所有的

### 分布式操作操作系统




## 多处理器和多核操作系统设计
一个处理器里面有很多个核心
多处理器考虑的问题是并发，调度，同步等问题

多核操作系统

## 了解Windows

[ 第 1 层 ] 硬件抽象层 HAL
[ 第 2 层 ] 微内核层 Kernel（调度、同步、中断）
[ 第 3 层 ] 执行体层 Executive（系统服务模块）
[ 第 4 层 ] 系统进程层 System Processes（用户态服务子系统）
[ 第 5 层 ] 应用接口层 API（Win32 / .NET / 驱动接口）


Windosw的内核组件：执行体 内核 硬件抽象层等等
针对执行体，有很多系统函数模块

客户-服务器模型
Windows 的用户模式和内核模式通过一个 客户-服务器架构 来通信
线程和SMP  多核并行的调度

Windows对象

## 传统的UNIX系统
UNIX系统的成功基石（​​可移植性​​和​​C语言实现​​）及其经典的​​分层、内核中心化​​的架构设计



## linux操作系统介绍

### linux的历史
### 模块结构
模块化指的是将内核的功能划分为一系列相对独立、可分离的代码块（即模块）。
#### 当我把一个模块（比如一个驱动）加载进内核后，内核内部是如何记录它、并让其他模块能使用它提供的功能的？

每个模块在内核里面有一个模块表，里面有关键字段

# 练习，关键术语，复习题和习题

## 关键术语

批处理（Batch processing）

指把一组作业（job）收集起来一次性按顺序自动处理的方式，用户不与作业交互。常用于早期大型机作业，例如把若干打印/计算任务连成一个批次。

批处理系统（Batch operating system）

以批处理为主要工作方式的操作系统，负责接收作业、排队、调度并自动运行，优势是对资源利用率好但响应时间长。

执行上下文（Execution context / Context）

指进程或线程在CPU上运行所需的全部状态信息（寄存器、程序计数器、栈指针、内存映射等）。中断/切换时必须保存与恢复。

分布式操作系统（Distributed OS）

把多台物理主机的资源整合，向用户呈现为单一系统的操作系统，支持网络上的资源共享与统一管理。

管程（Monitor）

一种并发控制结构（同步原语），封装共享资源和对其的操作，同时提供互斥和条件等待机制，用于进程/线程同步。

单体内核（Monolithic kernel）

把操作系统大部分功能（调度、文件系统、网络驱动等）都放在内核空间实现的内核设计，优点：性能好、功能集中；缺点：体积大、扩展性/稳定性相对差。

多道批处理系统（Multiprogrammed batch system）

在单台机器上同时保留多个作业在内存中并发存在，让CPU在作业间切换以提高利用率（与早期单道批处理不同）。

多道程序设计（Multiprogramming）

将多道程序同时装入内存，根据需要切换运行，以利用CPU空闲时间（如等待I/O时运行其他程序）。

时间片轮转（Round-robin）

一种调度算法：给每个可运行进程分配固定的CPU时间片，时间片用完就切换到下一个，简单且响应公平。

调度（Scheduling）

操作系统决定哪个进程/线程获得CPU、何时运行的机制，包括短期调度（CPU分配）、长期/中期调度（进程入/出内存）等。

串行处理（Serial processing）

一次只执行一个任务或作业的处理方式，与并行/并发相对，简单但效率低。

状态（State）

通常指进程/线程的当前状态（如就绪、运行、阻塞/等待、终止等），用于调度和管理。

空闲时间 / 空机时间（Idle time）

（图片可能写作“空闲时间/若机时间”）CPU没有可运行任务时的时间段；设计调度/多道程序的目的是尽量减少空闲时间。

错误（Error）

系统运行中出现的不正常条件（硬件故障、非法指令、算术溢出等），通常会触发异常处理或中断。

中断（Interrupt）

硬件或软件发出的信号，用于打断当前执行以处理重要事件（I/O完成、定时器、异常），是实现并发与响应的重要机制。

作业（Job）

用户提交给系统执行的单位任务（例如一组指令、批处理任务），在批处理系统中特别常见。

作业控制语言（JCL）

用于向批处理系统描述作业、输入输出设备和运行参数的脚本语言（如大型机上的JCL）。

内核（Kernel）

操作系统的核心部分，负责资源管理、进程调度、内存管理、设备驱动等，运行在特权（内核）模式下。

内核模式（Kernel mode）

CPU的一种运行模式，允许执行所有指令并访问所有资源；与用户模式相对，内核代码在此模式下运行以保障系统安全。

可加载模块（Loadable module）

可在运行时动态加载/卸载的内核组件（比如驱动程序），增强内核的可扩展性和可维护性。

平均失效时间（MTTF, Mean Time To Failure）

一个系统或组件预期失效前的平均工作时间，用于衡量可靠性（数值越大越可靠）。

平均修复时间（MTTR, Mean Time To Repair）

从发生故障到修复完成的平均时间，和MTTF一起用于评估系统可用性。

内存管理（Memory management）

操作系统管理主存（分配、回收、保护、交换/置换等），常用技术包括分区、分页、分段、虚拟内存等。

微内核（Microkernel）

只把最基本功能（IPC、地址空间管理、线程调度）放内核，其他服务运行在用户空间的内核设计，优点：稳定、安全，缺点：可能性能开销大。

多任务（Multitasking）

在操作系统上能同时管理多个任务（进程/线程），通过快速切换给人以并发执行的感觉。分为抢占式和协作式。

多线程（Multithreading）

在单个进程内并发执行多个执行流（线程），线程之间共享进程的地址空间和资源，切换开销小。

核心（Core / Kernel）

可指CPU核心（core）或操作系统内核（kernel）；在上下文中多半指“内核”或“关键部分”。

面向对象程序设计（OOP）

一种程序设计范式，强调类与对象、封装、继承和多态，现代操作系统的部分组件或接口可能用OOP方法实现。

操作系统（Operating System）

管理硬件与软件资源、为用户和应用提供服务的系统软件（进程管理、内存、文件系统、设备、网络、安全等）。

物理地址（Physical address）

实际主存（RAM）的地址，由内存硬件使用；与虚拟地址相对，虚拟地址需经地址变换映射到物理地址。

特权指令（Privileged instruction）

只能在内核/特权模式下执行的CPU指令（如关中断、直接I/O操作），用于保护系统关键资源。

进程（Process）

程序在运行时的实例，包含程序代码、数据、堆栈、打开文件和执行上下文。是资源分配的基本单位。

进程状态（Process state）

进程的生命周期状态，常见有：新建 → 就绪 → 运行 → 等待/阻塞 → 终止。

实地址（Real address）

有时指物理地址或在无虚拟内存系统中的地址空间；即直接对应主存的地址。

可靠性（Reliability）

系统在指定条件下和时间内不发生故障的能力，通常与MTTF、故障率等指标相关。

常驻监控程序（Resident monitor）

早期操作系统的形式，常驻内存的一段程序，负责作业调度、设备控制等，是现代内核的前身。

循环制（可能指“轮循/循环调度”）

可指系统以循环方式轮询检查设备/任务状态或按循环顺序调度任务（与时间片轮转类似）。（图中可能写成“循环制”或“循环制”）

对称多处理（SMP, Symmetric multiprocessing）

多处理器系统中各处理器地位对等，共享主存与I/O，总体由单一操作系统实例管理，常用于服务器/多核系统。

任务（Task）

泛指工作单元，在不同上下文可代表进程或线程；有时在实时/嵌入式系统中用task表示调度对象。

线程（Thread）

轻量级的执行单元，属于进程的一部分，拥有自己的程序计数器、寄存器和栈，但共享进程资源。

分时（Time-sharing）

系统把CPU时间划分成短时间片，多个用户/进程轮流使用CPU，提供交互式响应能力。

分时系统（Time-sharing system）

支持多个交互用户同时使用计算资源的操作系统，通过时间片轮转等机制保证响应时间。

时间片（Time slice / Quantum）

调度中分配给每个进程/线程的连续CPU运行时间长度，时间片长短影响响应与吞吐权衡。

单进程程序设计（Single-process programming）

程序一次只有一个进程在运行或程序自身不使用多进程/多线程，简单但不能并行利用多核或覆盖I/O等待。

正常运行时间（Uptime）

系统从启动到当前或最近一次重启/故障的持续运行时间，用于衡量稳定性。

用户模式（User mode）

CPU运行的受限模式，应用代码在此运行，不能执行特权指令或直接访问硬件，需要通过系统调用进入内核服务。

虚拟地址（Virtual address）

进程看到的逻辑地址空间，通过内存管理单元（MMU）映射到物理地址，支持进程隔离与虚拟内存。

虚拟机（Virtual machine）

在主机上虚拟出的完整计算机环境，运行自己的操作系统（如VMware、KVM），便于隔离与资源分配。

虚拟内存（Virtual memory）

把磁盘空间作为扩展内存来使用，通过分页/分段和置换算法实现，把进程的虚拟地址映射到物理内存或磁盘（交换空间），提高内存利用率并提供每进程独立地址空间。









